---
jupytext:
  formats: ipynb,md:myst
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.17.3
kernelspec:
  display_name: Python 3 (ipykernel)
  language: python
  name: python3
---

+++ {"editable": true, "slideshow": {"slide_type": "slide"}}

# Лекция 5. Алгоритмы сортировки

Алгоритмы и структуры данных

МГТУ им. Н.Э. Баумана

Красников Александр Сергеевич

2024-2025

+++ {"editable": true, "slideshow": {"slide_type": "slide"}}

## План лекции
1. Простейшие методы сортировки
2. Продвинутые методы сортировки

+++ {"editable": true, "slideshow": {"slide_type": "slide"}}

## Определение

**Сортировка** - процесс упорядочивания данных по возрастанию (убыванию) их значений.

+++ {"editable": true, "slideshow": {"slide_type": "slide"}}

# Свойства и типы

- **Устойчивость** — устойчивая сортировка не меняет взаимного расположения элементов с одинаковыми ключами.
- **Естественность поведения** — эффективность метода при обработке уже упорядоченных или частично упорядоченных данных. Алгоритм ведёт себя естественно, если учитывает эту характеристику входной последовательности и работает лучше.
- **Использование операции сравнения**. Алгоритмы, использующие для сортировки сравнение элементов между собой, называются основанными на сравнениях. Минимальная трудоёмкость худшего случая для этих алгоритмов составляет $n\cdot \log n$, но они отличаются гибкостью применения. Для специальных случаев (типов данных) существуют более эффективные алгоритмы.
- **Cфера применения**  —
  - Внутреняя
  - Внешняя

+++ {"editable": true, "slideshow": {"slide_type": "slide"}}

### Обмен элементов

Практически во всех методах сортировки есть необходимость обмена местами элементов. 
Этот обмен можно реализовать разными способами.

Обычно обмен производится с привлечением дополнительной переменной

```{code-cell} ipython3
---
editable: true
slideshow:
  slide_type: fragment
---
a = 3
b = 5

temp = a
a = b
b = temp

print('a =', a, 'b =', b)
```

+++ {"editable": true, "slideshow": {"slide_type": "slide"}, "jp-MarkdownHeadingCollapsed": true}

В Python можно совершить обмен без привлечения дополнительной переменной

```{code-cell} ipython3
---
editable: true
slideshow:
  slide_type: fragment
jp-MarkdownHeadingCollapsed: true
---
a = 3
b = 5

a, b = b, a

print('a =', a, 'b =', b)
```

+++ {"editable": true, "slideshow": {"slide_type": "slide"}, "jp-MarkdownHeadingCollapsed": true}

Для наглядности и единнобразия можно создать функцию `swap` для обмена местами значений переменных

```{code-cell} ipython3
---
editable: true
slideshow:
  slide_type: subslide
---
def swap(a, b):
    '''Обмен значений переменных'''
    return b, a


# Пример использования:
x = 5
y = 10

print(f'x = {x}, y = {y}')
x, y = swap(x, y)
print(f'x = {x}, y = {y}')
```

+++ {"editable": true, "slideshow": {"slide_type": "slide"}}

Также можно создать "процедуру" для обмена элементов массива

```{code-cell} ipython3
---
editable: true
slideshow:
  slide_type: subslide
---
def swap(arr, i, j):
    '''Обмен значений переменных'''
    temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp


# Пример использования:
arr = [0, 1, 2, 3, 4]

print(arr)
swap(arr, 2, 3)
print(arr)
```

+++ {"editable": true, "slideshow": {"slide_type": "slide"}}

## Обзор наиболее популярных алгоритмов сортировки

+++ {"editable": true, "slideshow": {"slide_type": "slide"}}

### Алгоритмы устойчивой сортировки

| Алгоритм | Описание | Время исполнения (худший случай) | Время исполнения (средний случай) | Время исполнения (лучший случай) | Затраты памяти | Примечание |
|----------|----------|----------------------------------|-----------------------------------|----------------------------------|----------------|-------------|
| [Сортировка пузырьком](https://ru.wikipedia.org/wiki/Сортировка_пузырьком) (Bubble sort) | Проходит по массиву, сравнивает последовательные пары элементов и меняет их местами, если они расположены в неправильном порядке. | $O(n^2)$ | $O(n^2)$ | $O(n)$ | $O(1)$ | В процессе сортировки минимальный элемент «всплывает» вверх массива, напоминая пузырь |
| [Сортировка перемешиванием](https://ru.wikipedia.org/wiki/Сортировка_перемешиванием) (Cocktail sort) | Двунаправленный, оптимизированный вариант сортировки пузырьком | $O(n^2)$ | $O(n^2)$ | $O(n)$ | $O(1)$ | — |
| [Сортировка вставками](https://ru.wikipedia.org/wiki/Сортировка_вставками) (Insertion sort) | Элементы входной последовательности просматриваются по одному, и каждый новый поступивший элемент размещается в подходящее место среди ранее упорядоченных элементов | $O(n^2)$ | $O(n^2)$ | $O(n)$ | $O(1)$ | — |
| [Гномья сортировка](https://ru.wikipedia.org/wiki/Гномья_сортировка) (Gnome sort) | Гибрид сортировок вставками и пузырьком. | $O(n^2)$ | $O(n^2)$ | $O(n)$ | $O(1)$ | Название происходит от предполагаемого поведения садовых гномов при сортировке линии садовых горшков |
| [Сортировка слиянием](https://ru.wikipedia.org/wiki/Сортировка_слиянием) (Merge sort) | Рекурсивно сортирует половины массива, а затем комбинирует их в один | $O(n\log{n})$ | $O(n\log{n})$ | $O(n\log{n})$ | $O(n)$ | — |
| [Сортировка с помощью двоичного дерева](https://ru.wikipedia.org/wiki/Tree_sort) (Tree sort) | На основе исходных данных строится двоичное дерево поиска, в котором последовательно собираются минимальные значения | $O(n^2)$ | $O(n\log{n})$ | $O(n\log{n})$ | $O(n)$ | — |
| Сортировка [Timsort](https://ru.wikipedia.org/wiki/Timsort) (Timsort) | Гибрид сортировок вставками и слиянием. Основан на предположении, что при решении практических задач входной массив зачастую состоит из отсортированных подмассивов | $O(n\log{n})$ | $O(n\log{n})$ | $O(n)$ | $O(n)$ | — |

+++ {"editable": true, "slideshow": {"slide_type": "slide"}}

## Алгоритмы неустойчивой сортировки

| Алгоритм | Описание | Время исполнения (худший случай) | Время исполнения (средний случай) | Время исполнения (лучший случай) | Затраты памяти | Примечание |
|----------|----------|----------------------------------|-----------------------------------|----------------------------------|----------------|-------------|
| [Сортировка выбором](https://ru.wikipedia.org/wiki/Сортировка_выбором) (Selection sort) | Делит входной массив на упорядоченную и неупорядоченную части. Затем последовательно переносит в первую часть наименьшие элементы из второй | $O(n^2)$ | $O(n^2)$ | $O(n^2)$ | $O(1)$ | — |
| [Сортировка расчёской](https://ru.wikipedia.org/wiki/Сортировка_расчёской) (Comb sort) | Модификация сортировки пузырьком, в которой расстояние между сравниваемыми парами значений отлично от 1 | $O(n^2)$ | $O(n^2/2^p)$ | $O(n\log{n})$ | $O(1)$ | Несмотря на бо́льшую алгоритмическую сложность, при не очень больших размерах массива сортировка расчёской будет более эффективна, чем быстрая сортировка |
| [Сортировка Шелла](https://ru.wikipedia.org/wiki/Сортировка_Шелла) (Shell sort) | Модификация сортировки вставками, в которой расстояние между сравниваемыми парами значений отлично от 1 | $O(n^2)$ | $O(n\log^2{n})$ | $O(n)$ | $O(1)$ | — |
| [Пирамидальная сортировка](https://ru.wikipedia.org/wiki/Пирамидальная_сортировка) (Heapsort) | На основе исходных данных строится двоичная куча, в которой последовательно собираются минимальные значения | $O(n\log{n})$ | $O(n\log{n})$ | $O(n\log{n})$ | $O(1)$ | — |
| [Плавная сортировка](https://ru.wikipedia.org/wiki/Smoothsort) (Smoothsort) | Модификация пирамидальной сортировки, оптимизирующая сортировку частично упорядоченного массива | $O(n\log{n})$ | $O(n\log{n})$ | $O(n)$ | $O(n)$ | — |
| [Быстрая сортировка](https://ru.wikipedia.org/wiki/Быстрая_сортировка) (Quicksort) | Выбирается опорный элемент p. Все ключи, меньшие p, перемещаются влево от него, а все ключи, большие либо равные p, вправо. Далее алгоритм рекурсивно применяется к каждой из частей | $O(n^2)$ | $O(n\log{n})$ | $O(n\log{n})$ | $O(\log{n})$ | — |
| [Интроспективная сортировка](https://ru.wikipedia.org/wiki/Introsort) (Introsort) | Гибрид быстрой и пирамидальной сортировок | $O(n\log{n})$ | $O(n\log{n})$ | $O(n\log{n})$ | $O(n)$ | — |
| [Придурковатая сортировка](https://ru.wikipedia.org/wiki/Stooge_sort) (Stooge sort) | Меняет местами первый и последний элементы массива, если необходимо. Затем делит массив на три части, в каждой из которых запускается рекурсивно | $O(n^{\log{3} / \log{1.5}}) = O(n^{2.709...})$ | $O(n^{2.709...})$ | $O(n^{2.709...})$ | $O(1)$ | Метод назван в честь американской комик-группы «Три балбеса» («Three stooges»). Сходство заключается в том, что алгоритм безумно мечется по уже отсортированным третям массива. |

+++ {"editable": true, "slideshow": {"slide_type": "slide"}}

## Непрактичные алгоритмы сортировки

| Алгоритм | Описание | Время исполнения (худший случай) | Время исполнения (средний случай) | Время исполнения (лучший случай) | Затраты памяти | Примечание |
|----------|----------|----------------------------------|-----------------------------------|----------------------------------|----------------|-------------|
| [Bogosort](https://ru.wikipedia.org/wiki/Bogosort) | Массив произвольно перемешивается до тех пор, пока не окажется отсортированным | Неограниченно | $O(n!)$ | $O(n)$ | $O(1)$ | Используется только в академических целях |
| [Сортировка перестановкой](https://ru.wikipedia.org/wiki/Сортировка_перестановкой) | Генерируются все возможные последовательности массива, из которых выбирается упорядоченная | $O(n!)$ | $O(n!)$ | $O(n!)$ | $O(n)$ | Используется только в академических целях |
| [Гравитационная сортировка](https://ru.wikipedia.org/wiki/Bead_sort) (Bead sort) | Числа представляются в виде бусинок на штырях, затем сортируются под действием гравитации | $O(\sqrt{n})$ | $O(\sqrt{n})$ | $O(\sqrt{n})$ | $O(n^2)$ | Требуется специализированное аппаратное обеспечение |

+++ {"editable": true, "slideshow": {"slide_type": "slide"}}

## Алгоритмы, не основывающиеся на сравнениях

| Алгоритм | Описание | Время исполнения (худший случай) | Время исполнения (средний случай) | Время исполнения (лучший случай) | Затраты памяти | Примечание |
|----------|----------|----------------------------------|-----------------------------------|----------------------------------|----------------|-------------|
| [Блочная сортировка](https://ru.wikipedia.org/wiki/Блочная_сортировка) (Bucket sort) | Элементы распределяются по блокам согласно диапазону значений, каждый из которых затем рекурсивно сортируется | $O(n^2)$ | $O(n^2 + n/k + k)$ | $O(n + k)$ | $O(n + k)$ | $k$ — заранее известное количество корзин |
| [Поразрядная сортировка](https://ru.wikipedia.org/wiki/Поразрядная_сортировка) (Radix sort) | Массив сортируется с помощью поразрядного сравнения чисел | $O(wn)$ | $O(wn)$ | $O(wn)$ | $O(n)$ | $w$ — количество бит, требуемых для хранения каждого ключа |
| [Сортировка подсчётом](https://ru.wikipedia.org/wiki/Сортировка_подсчётом) (Counting sort) | Подсчитывается количество вхождений каждого целого числа из диапазона ключей в массив. Затем выводятся значения всех ненулевых значений | $O(n + k)$ | $O(n + k)$ | $O(n + k)$ | $O(n + k)$ | $k$ — максимальное значение элементов ключа |

+++ {"editable": true, "slideshow": {"slide_type": "slide"}}

## Простейшие методы сортировки

Простейшие методы имеют оценку сложности $O(n^2)$. 
Если n невелико, то такие алгоритмы вполне могут считаться эффективными, благодаря простоте реализации. 
Но с ростом числа элементов будет неизбежно возрастать время сортировки, поэтому при больших n предпочтение нужно отдать более &laquo;продвинутым&raquo; алгоритмам.

+++ {"editable": true, "slideshow": {"slide_type": "slide"}, "jp-MarkdownHeadingCollapsed": true}

К простейшим алгоритмам сортировки можно отнести:

- непрактичную сортировку;
- сортировку вставками;
- сортировку выбором;
- пузырьковую сортировку.

+++ {"editable": true, "slideshow": {"slide_type": "slide"}}

### Непрактичная сортировка (Unratio Sort)

Самой простой для запоминания является непрактичная сортировка.
Сортировка считается непрактичной из-за лишних операций сравнения и обмена (например, arr[0] с arr[0]).

```{code-cell} ipython3
---
editable: true
slideshow:
  slide_type: subslide
jp-MarkdownHeadingCollapsed: true
---
def unratio_sort(arr):
    '''Непрактичная сортировка'''
    n = len(arr)
    arr = arr[:]
    for i in range(n):
        for j in range(n):
            if arr[i] < arr[j]:
                arr[i], arr[j] = arr[j], arr[i]
    return arr

# Пример использования
data = [44, 55, 12, 42, 94, 18, 16, 67]
print('Исходный массив данных:', data)
print("Отсортированный массив:", unratio_sort(data))
```

```{code-cell} ipython3
---
editable: true
slideshow:
  slide_type: ''
---
def unratio_sort(arr):
    '''Непрактичная сортировка'''
    n = len(arr)
    arr = arr[:]
    for i in range(n):
        for j in range(n):
            if arr[i] < arr[j]:
                swap(arr, i, j)
    return arr

# Пример использования
data = [44, 55, 12, 42, 94, 18, 16, 67]
print('Исходный массив данных:', data)
print("Отсортированный массив:", unratio_sort(data))
```

+++ {"editable": true, "slideshow": {"slide_type": ""}}

### Сортировка вставками (Insertion Sort)

Сортировка вставками  — алгоритм сортировки, в котором элементы входной последовательности просматриваются по одному, и каждый новый поступивший элемент размещается в подходящее место среди ранее упорядоченных элементов

Именно таким образом обычно сортируют карты: держав левой руке уже упорядоченные карты и взяв правой рукой очередную
карту мы вставляем ее в нужное место, сравнивая с уже имеющимися, двигаясь справа налево.
Сортировка вставками удобна для сортировки коротких последовательностей элементов. 

Описание алгоритма:

```
44 \\ 55 12 42 94 18 16 67
44 55 \\ 12 42 94 18 16 67
12 44 55 \\ 42 94 18 16 67
12 42 44 55 \\ 94 18 16 67
12 42 44 55 94 \\ 18 16 67
12 18 42 44 55 94 \\ 16 67
12 16 18 42 44 55 94 \\ 67
12 16 18 42 44 55 67 94 \\
```

```{code-cell} ipython3
---
editable: true
slideshow:
  slide_type: subslide
---
def insertion_sort(arr):
    '''Сортировка вставками'''
    n = len(arr)
    arr = arr[:]
    for i in range(1, n):
        current_item = arr[i]
        j = i - 1
        while (j >= 0) and (current_item < arr[j]):
            arr[j+1] = arr[j]
            j -= 1
        arr[j+1] = current_item
    return arr

# Пример использования
data = [44, 55, 12, 42, 94, 18, 16, 67]
print('Исходный массив данных:', data)
print("Отсортированный массив:", insertion_sort(data))
```

+++ {"editable": true, "slideshow": {"slide_type": "slide"}}

### Сортировка выбором (Selection Sort)

Сортировка выбором – это один из простейших алгоритмов сортировки. 
Он работает по принципу нахождения наименьшего (или наибольшего) элемента в не отсортированной части массива и обмена его с первым элементом не отсортированной части, а затем повторения этой операции для оставшихся элементов.

Описание алгоритма:

1. Начинаем с первого элемента массива (это будет "текущий" элемент).
2. Смотрим на все остальные элементы массива, начиная со второго, ищем наименьший элемент (или наибольший, в зависимости от направления сортировки).
3. После того, как наименьший элемент найден, он меняется местами с текущим элементом.
4. Переходим к следующему элементу и повторяем процесс, пока не отсортируем весь массив.

```{code-cell} ipython3
---
editable: true
slideshow:
  slide_type: subslide
jp-MarkdownHeadingCollapsed: true
---
def selection_sort(arr):
    '''Сортировка выбором'''
    n = len(arr)
    arr = arr[:]
    for i in range(n - 1):
        # Предполагаем, что текущий элемент - наименьший
        min_index = i
        for j in range(i + 1, n):
            if arr[j] < arr[min_index]:
                min_index = j
        # Меняем местами найденный наименьший элемент с текущим
        #arr[i], arr[min_index] = arr[min_index], arr[i]
        swap(arr, i, min_index)
    return arr

# Пример использования
data = [44, 55, 12, 42, 94, 18, 16, 67]
print('Исходный массив данных:', data)
print("Отсортированный массив:", selection_sort(data))
```

+++ {"editable": true, "slideshow": {"slide_type": "slide"}}

### Пузырьковая сортировка (Bubble Sort)

Для сортировки N-элементного массива методом пузырька требуется до N − 1 проходов. 
В каждом проходе сравниваются соседние элементы, и если, первый из них больше или равен второму, эти элементы меняются местами.

В избыточном варианте циклы выполняются независимо от начального расположения элементов, что ведёт к лишним операциям сравнения, если массив уже упорядочен.

```{code-cell} ipython3
---
editable: true
slideshow:
  slide_type: subslide
---
def bubble_sort(arr):
    '''Пузырьковая сортировка'''
    n = len(arr)
    arr = arr[:]
    for i in range(n):
        for j in range(n-i-1):
            if arr[j] > arr[j + 1]:
                #arr[j], arr[j+1] = arr[j+1], arr[j]
                swap(arr, j, j+1)
    return arr

# Пример использования
data = [44, 55, 12, 42, 94, 18, 16, 67]
print('Исходный массив данных:', data)
print("Отсортированный массив:", bubble_sort(data))
```

+++ {"editable": true, "slideshow": {"slide_type": "slide"}}

### Итоги 

К положительным качествам простейших методов сортировки относят
- экономное расходование памяти
- простота реализации
Главным недостатком сортировок методом вставок, выбора, пузырька является низкая производительность

+++ {"editable": true, "slideshow": {"slide_type": "slide"}}

## Продвинутые методы сортировки

+++ {"editable": true, "slideshow": {"slide_type": "slide"}}

### Быстрая сортировка (Quick Sort)

QuickSort - широко известный алгоритм сортировки, разработанный английским учёным Чарльзом Хоаром.
Один из быстрых известных универсальных алгоритмов сортировки массивов, являющийся также, наиболее распространённым.

Краткое описание работы:

- выбрать элемент, называемый опорным
- сравнить все остальные элементы с опорным, на основании сравнения разбить множество на три — меньшие опорного,
равные и большие, расположить их в порядке меньшие-равные-большие.
- повторить рекурсивно для меньших и больших.

+++ {"editable": true, "slideshow": {"slide_type": "slide"}}

Достоинства:
- Один из самых быстродействующих (на практике) из алгоритмов внутренней сортировки общего назначения.
- Прост в реализации.
- Требует лишь O(logn) дополнительной памяти для своей работы.
- Хорошо сочетается с механизмами кэширования и виртуальной памяти.

Недостатки:
- Сильно деградирует по скорости (до $O(n^2)$) при неудачных выборах опорных элементов, что может случиться при неудачных входных данных. Этого можно избежать, выбирая опорный элемент случайно, а не фиксированным образом.
- Наивная реализация алгоритма может привести к ошибке переполнения стека, так как ей может потребоваться сделать $O(n)$ вложенных рекурсивных вызовов. В улучшенных реализациях, в которых рекурсивный вызов происходит только для сортировки большей из двух частей массива, глубина рекурсии гарантированно не превысит $O(logn)$.

```{code-cell} ipython3
---
editable: true
slideshow:
  slide_type: subslide
---
def quick_sort(arr, start, end):
    '''Быстрая сортировка'''
    if end - start > 1:
        p = partition(arr, start, end)
        quick_sort(arr, start, p)
        quick_sort(arr, p + 1, end)
    return(arr)
 
def partition(arr, start, end):
    pivot = arr[start]
    i = start + 1
    j = end - 1
 
    while True:
        while (i <= j and arr[i] <= pivot):
            i = i + 1
        while (i <= j and arr[j] >= pivot):
            j = j - 1
 
        if i <= j:
            #arr[i], arr[j] = arr[j], arr[i]
            swap(arr, i, j)
        else:
            #arr[start], arr[j] = arr[j], arr[start]
            swap(arr, start, j)
            return j

# Пример использования
data = [44, 55, 12, 42, 94, 18, 16, 67]
print('Исходный массив данных:', data)
print("Отсортированный массив:", quick_sort(data, 0, len(data)))
```

+++ {"editable": true, "slideshow": {"slide_type": "slide"}}

### Сортировка Шелла (Shell Sort)

Идея метода заключается в сравнение разделенных на группы элементов последовательности, находящихся друг от друга на некотором расстоянии. 
Изначально это расстояние равно d или $N/2$, где N — общее число элементов. 
На первом шаге каждая группа включает в себя два элемента расположенных друг от друга на расстоянии $N /2$; они сравни-
ваются между собой, и, в случае необходимости, меняются местами.
На последующих шагах также происходят проверка и обмен, но расстояние d сокращается на d/2, и количество групп, соответственно, уменьшается.
Постепенно расстояние между элементами уменьшается, и на d=1 проход по массиву происходит в последний раз.

```{code-cell} ipython3
---
editable: true
slideshow:
  slide_type: subslide
---
def shell_sort(arr):
    '''Сортировка Шелла'''
    n = len(arr)
    arr = arr[:]
    step = len(arr) // 2
    while step > 0:
        for i in range(step, n, 1):
            j = i
            delta = j - step
            while delta >= 0 and arr[delta] > arr[j]:
                #arr[delta], arr[j] = arr[j], arr[delta]
                swap(arr, delta, j)
                j = delta
                delta = j - step
        step //= 2
    return arr
    
# Пример использования
data = [44, 55, 12, 42, 94, 18, 16, 67]
print('Исходный массив данных:', data)
print("Отсортированный массив:", shell_sort(data))
```

+++ {"editable": true, "slideshow": {"slide_type": "slide"}}

Интересно, но качество данного алгоритма зависит от последовательности значений d.
Существует несколько подходов к выбору этих значений:

1. Первоначально используемая Шеллом последовательность длин промежутков:
d[1] = N/2, d[i] = d[i−1] / 2, d[k] = 1 в худшем случае, сложность алгоритма составит $O(N^2)$
2. Предложенная Хиббардом последовательность: все значения $2^i − 1 \leqslant N$, $i \in N$ такая последовательность шагов приводит к алгоритму сложностью $O(N^{3/2})$
3. Предложенная Седжвиком последовательность:
- $d[i] = 9 \cdot 2^i − 9 \cdot 2^{i/2} + 1$ , если i четное и
- $d[i] = 8 \cdot 2^i − 6 \cdot 2^{(i+1)/2} + 1$ , если i нечетное.
  
При использовании таких приращений средняя сложность алгоритма составляет: $O(n^{7/6})$, а в худшем случае порядка $O(n^{4/3})$.

+++ {"editable": true, "slideshow": {"slide_type": "slide"}}

###  Сортировка слиянием (Merge Sort)

Слияние означает объединение двух (или более) последовательностей в одну упорядоченную последовательность при помощи циклического выбора элементов, доступных в данный момент.

Сначала задача разбивается на несколько подзадач меньшего размера.
Затем эти задачи решаются с помощью рекурсивного вызова или непосредственно, если их размер достаточно мал. Затем их решения комбинируются, и получается решение исходной задачи.

+++ {"editable": true, "slideshow": {"slide_type": "slide"}}

Процедура слияния предполагает объединение двух предварительно упорядоченных подпоследовательностей размерности n/2 в единую последовательность размерности n. 
Начальные элементы предварительно упорядоченных последовательностей сравниваются между собой, и из них выбирается наименьший. 
Соответствующий указатель перемещается на следующий элемент. 
Процедура повторяется до тех пор, пока не достигнут конец одной из подпоследовательностей. 
Оставшиеся элементы другой подпоследовательности при этом передаются в результирующую последовательность в еизменном виде.

```{code-cell} ipython3
---
editable: true
slideshow:
  slide_type: subslide
---
def merge_sort(arr, left_index, right_index): 
    '''Сортировка слиянием'''
    if left_index >= right_index: 
        return 
 
    middle = (left_index + right_index)//2 
    merge_sort(arr, left_index, middle) 
    merge_sort(arr, middle + 1, right_index) 
    merge(arr, left_index, right_index, middle) 
    
 
     
def merge(arr, left_index, right_index, middle): 
    '''Деление массива на части'''
 
     # Разбиение массива на части
    left_sublist = arr[left_index:middle + 1] 
    right_sublist = arr[middle+1:right_index+1] 
 
    # Переменные для отслеживания положения в каждом подмассиве 
    left_sublist_index = 0 
    right_sublist_index = 0 
    sorted_index = left_index 
 
    # Обход по обеим копиям, пока не закончится один из подмвссивов
    while left_sublist_index < len(left_sublist) and right_sublist_index < len(right_sublist): 
 
        # Если в left_sublist есть элемент меньшего размера, помещаем его в отсортированную часть, 
        if left_sublist[left_sublist_index] <= right_sublist[right_sublist_index]: 
            arr[sorted_index] = left_sublist[left_sublist_index] 
            left_sublist_index = left_sublist_index + 1 
        # Иначе добавляем его в right_sublist 
        else: 
            arr[sorted_index] = right_sublist[right_sublist_index] 
            right_sublist_index = right_sublist_index + 1 
  
        # Продвигаемся вперед по отсортированной части 
        sorted_index = sorted_index + 1 
       
    # Просмотр и добавление оставшихся элементов 
    while left_sublist_index < len(left_sublist): 
        arr[sorted_index] = left_sublist[left_sublist_index] 
        left_sublist_index = left_sublist_index + 1 
        sorted_index = sorted_index + 1 
    while right_sublist_index < len(right_sublist): 
        arr[sorted_index] = right_sublist[right_sublist_index] 
        right_sublist_index = right_sublist_index + 1 
        sorted_index = sorted_index + 1 

# Пример использования
data = [44, 55, 12, 42, 94, 18, 16, 67]
print('Исходный массив данных:', data)
merge_sort(data, 0, len(data))
print("Отсортированный массив:", data)
```

+++ {"editable": true, "slideshow": {"slide_type": "slide"}}

### TimSort

TimSort — это гибридный алгоритм сортировки, используемый по умолчанию в Python (в функциях sorted() и методе .sort() у списков). 

Он был разработан Тимом Питерсом (Tim Peters) в 2002 году. 

Полная реализация очень сложна (включает в себя вставки, слияния, управление "ранами" и т.д.):

```{code-cell} ipython3
---
editable: true
slideshow:
  slide_type: subslide
---
def insertion_sort(arr, left, right):
    """Сортировка вставками для небольших подмассивов."""
    for i in range(left + 1, right + 1):
        key = arr[i]
        j = i - 1
        while j >= left and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key

def merge(arr, l, m, r):
    """Слияние двух отсортированных подмассивов."""
    left = arr[l:m + 1]
    right = arr[m + 1:r + 1]
    
    i = j = 0
    k = l

    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            arr[k] = left[i]
            i += 1
        else:
            arr[k] = right[j]
            j += 1
        k += 1

    while i < len(left):
        arr[k] = left[i]
        i += 1
        k += 1

    while j < len(right):
        arr[k] = right[j]
        j += 1
        k += 1

def timsort(arr):
    """Упрощённая реализация TimSort."""
    n = len(arr)
    if n <= 1:
        return arr

    # Минимальный размер "рана" (обычно 32 или 64 в реальной реализации)
    min_run = 32

    # Шаг 1: Сортируем подмассивы размером min_run с помощью сортировки вставками
    for start in range(0, n, min_run):
        end = min(start + min_run - 1, n - 1)
        insertion_sort(arr, start, end)

    # Шаг 2: Последовательно сливаем отсортированные подмассивы
    size = min_run
    while size < n:
        for left in range(0, n, 2 * size):
            mid = min(left + size - 1, n - 1)
            right = min(left + 2 * size - 1, n - 1)
            if mid < right:
                merge(arr, left, mid, right)
        size *= 2

    return arr


# Пример использования
data = [44, 55, 12, 42, 94, 18, 16, 67]
print('Исходный массив данных:', data)
timsort(data)
print("Отсортированный массив:", data)
```
